\subsection{Identifying Theories via Implicit Isomorphisms}\label{sec:inverse}

In this section, we introduce several language extensions that introduce implicit isomorphisms.

Note that because identity morphisms are implicit, our uniqueness requirement for implicit morphisms implies that two theories $S$ and $T$ must be isomorphic if there are implicit morphisms in both directions.
Moreover, making a pair of isomorphisms implicit is well-formed if there are no other implicit morphisms between $S$ and $T$ yet.

\paragraph{Renamings}
We say that a named morphism $r:S\to T=\{\ldots\}$ is a \textbf{renaming} if
\begin{compactitem}
 \item all assignments in its body are of the form $c:=c'$ for $T$-constants $c'$ without definiens
 \item every such $T$-constants $c'$ occurs in exactly one assignment.
\end{compactitem}
Clearly, every renaming is an isomorphism.
The inverse morphisms contains the flipped assignments $c':=c$.

We make the following extension to syntax and semantics:
\begin{compactitem}
  \item A morphism declaration $r:s\to t=\{\ldots\}$ may carry the attribute \keyword{renaming}.
  \item This is well-formed if there are no implicit morphism between $s$ and $t$ yet.
  \item In that case, we define $r\in\IMo{s}{t}$ and $r^{-1}\in\Mo{t}{s}$.
\end{compactitem}

\ednote{@DM: add example, e.g., a definition of Monoid that uses different names}

\paragraph{Definitional Extensions}
We say that the named theory $t$ is a \textbf{definitional extension} of $S$ if $t=S$ or the body of $t$ contains
\begin{compactitem}
 \item only constant declarations with definiens,
 \item only include declarations of theories that are definitional extensions of $S$.
\end{compactitem}
\ednote{@DM: give example that extends Group with the theorem $(x^{-1})^{-1}\doteq x$ (with omitted proof)}

If $t$ is a definitional extension of $S$, it is easy to prove that $t$ and $S$ are isomorphic: both isomorphisms map all constants without definiens to themselves. In particular, the isomorphism $S\to t$ maps $S$-constants to themselves and expands the definiens of all other constants.

We make the following extension to syntax and semantics:
\begin{compactitem}
  \item An include declaration $\icl{s}$ of a named theory $s$ inside theory $t$ may carry the attribute \keyword{definitional}.
  \item In that case, we define $\id{s}\in\IMo{t}{s}$ (in addition to the implicit morphism $\id{t}\in\IMo{s}{t}$ which is induced by the inclusion).
\end{compactitem}

\ednote{@DM: repeat previous example now with \keyword{definitional} and give another definitional extensions of Group; this new extension may already use the implicitly available definition of the first extension}

\begin{remark}[Conservative Extensions]
A definitional extension is a special case of a conservative extension.
More generally, all retractable extensions are conservative, i.e., all extensions $S\harr T$ such that there is a morphism $r:T\to S$ such that $r$ is the identity on $S$.

But we cannot make the retractions implicit morphisms in general because they are not necessarily isomorphisms.
\end{remark}

\paragraph{Canonical Isomorphisms}
If we have isomorphisms $m:s\to t$ and $n:t\to s$, we simply spell them out in morphism declarations and add the keyword \keyword{implicit} to both.
This requires no language extensions.

\ednote{@DM: add the isomorphism of DG2G}
\begin{example}\label{group:iso}
We give the morphism $\cn{G2DG}$.

\end{example}

While the first one of these declarations is straightforward, the second one requires checking that $m$ and $n$ are actually isomorphism.
Otherwise, the uniqueness condition would be violated.
Thus, we have to check $m;n=\id{s}$ and $n;m=\id{t}$.
In general, the equality of two morphisms $f,g:A\to B$ is equivalent to $\vdash_B f(c)=g(c)$ for all $c:E\in\flt{A}$.
Thus, if equality of expressions is decidable in the logic that \mmt is instantiated with, then \mmt can check this directly.

However, this does not work in practice.
Already elementary examples require stronger, undecidable equality relations are used:

\begin{example}
Consider the isomorphism from Ex.~\ref{group:iso}.
The result of mapping $x\circ y$ from $\cn{Group}$ to $\cn{DivGroup}$ and back is $x\circ(unit\circ y^{-1})^{-1}$.
Clearly, the group axioms imply that this is equal to $x\circ y$.
But formally that requires working with the undecidable equality of first-order logic.
\end{example}

Therefore, in our running example, we only make one of the two isomorphisms implicit.

In the sequel, we design a general solution to this problem.
It allows systematically proving the equality of two morphisms and using that to make both isomorphisms implicit.
This is novel work, but it requires significant prerequisites and is only peripherally related to implicit morphisms.
Therefore, we only sketch the idea and leave the details to future work.

We add a language feature to \mmt to prove equalities between morphisms:
We add the productions
\begin{grammar}
Dia   & \rep{(TDec \alt MDec\alt MEq)}  &\\
MEq   & \keyword{equal} M=M:T\to T by \{\rep{Ass}\} &\\
\end{grammar}

%Firstly, the intuition of $\keyword{equality} T = \{c:=E,\ldots\}$ is that it provides to every base type $c:\type$ of $T$ a judgment $E:c\to c\to \type$ that defines the $T$-specific equality relation for objects of type $c$.
%Technically, this must be a binary logical relation in the sense of \cite{RS:logrels:12} on $\id{T}$.
%As described in \cite{RS:logrels:12}, this induces an equality predicate $\cn{Equal}_E:E\to E\to \type$ on every type $E$.

We define the declaration $M=N:S\to T by \{\sigma\}$ to be well-formed iff
\begin{compactitem} 
  \item $M:S\to T$ and $N:S\to T$ are well-formed morphisms
  \item $\sigma$ contains exactly one assignment $c:=p$ for every $(c:E)\in\flt{S}$
  \item for each of these assignments $c:=p$, the term $p$ is a proof of $\vdash_T M(c)=N(c)$.
\end{compactitem}

To make $m$ and $n$ from above implicit isomorphisms, we have to do three things: define $m$ and $n$, prove the equalities of $m;n=\id{s}$ and $n;m=\id{t}$, and make $m$ and $n$ implicit.
Note that we cannot make both $m$ and $n$ implicit right away because that is only well-formed after proving the equalities.)
Thus, we define a new attribute \keyword{implicit-later}, which states that a morphism should be considered implicit as soon as subsequent equality proves make it well-formed to do so.

\begin{example}[Isomorphisms]
We can now add declarations
 \[\keyword{implicit}:\cn{DG2G}:\cn{DivGroup}\to\cn{Group}=\text{(as above)}\]
 \[\keyword{implicit-later}:\cn{G2DG}:\cn{Group}\to\cn{DivGroup}=\text{(as above)}\]
 \[\keyword{equal}\cn{G2DG};\cn{DG2G}=\id{\cn{Group}}:\cn{Group}\to\cn{Group}=\text{(omitted)}\]
 \[\keyword{equal}\cn{DG2D};\cn{G2DG}=\id{\cn{DivGroup}}:\cn{DivGroup}\to\cn{DivGroup}=\text{(omitted)}\]
where the isomorphisms are as above and we omit all the equality proofs.
\end{example}

\subsection{Fine-Granular and Flexible Theory Hierarchies}
\input{example}

\subsection{Transparent Refactoring}

A major drawback of using modular theories is that it can preclude transparent refactoring.
For example, consider a theory $t=\{\icl{r},\icl{s}\}$, and assume we want to move a constant declaration $D$ for the name $n$ from $r$ to $s$.
Thus, the change to should be straightforward as it does not change the semantics of $t$.

However, this is not a local change.
It also requires updating every qualified reference from $r?n$ to $s?n$.
Such references can occur anywhere where $t$ is used.
That may include theories that the person who does the refactoring does not know or does not have access to.
Even if the source files always use the unqualified reference $n$ (because the checker is smart enough to dynamically disambiguate them), this still requires a global rebuild to reach a consistent state again.

With implicit morphisms, we can solve this problem by making only the following local changes:
\begin{compactenum}
  \item We rename $s$ to $s'$.
  \item We delete the declaration $n:E$ from $s'$.
  \item We create new theories $r'=\{\icl{r},\,D\}$ and $s=\{\icl{s'},D\}$.
  \item We change $t$ to $t=\{\icl{r'},\icl{s'}\}$.
  \item We add an implicit morphism $s\to t$ that maps $s?n$ to $r'?n$.
\end{compactenum}
Now $t$ has the desired new structure.
But, all old references to $s?n$ stay well-formed so that no global changes are needed.

\ednote{@DM: maybe make a tikz for the before/after situations}