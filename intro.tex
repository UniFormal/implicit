\paragraph{Motivation}
Theory morphisms have proved an essential tool for managing collections of theories in logics and related formal systems.
They can be used to structure theories and build large theories modularly from small components or to relate different theories to each other \cite{asl,devgraphs,littletheories}.
Areas in which tools based on theories and theory morphisms have been developed include specification \cite{obj,hets}, rewriting \cite{maude}, theorem proving \cite{imps}, and knowledge representation \cite{RK:mmt:10}.

%The latter of these tools is our \mmt system.
%We use \mmt as both a theoretical framework and a concrete implementation of our results.
%But our ideas are independent of \mmt and can be transferred very easily to any other language using theory morphisms.

These systems usually use a logic $L$ for the fine-granular formalization of domain knowledge, and a diagram $D$ in the category of $L$-theories and $L$-morphisms for the high-level structure of large bodies of knowledge.
This diagram is generated by all theories/morphisms defined, induced, or referenced in a user's development.

\begin{wrapfigure}{r}{5.5cm}
\vspace{-3em}
\begin{tikzpicture}
\node (M) at (0,0) {$\cn{Monoid}$};
\node (G) at (-2,-2) {$\cn{Group}$};
\node (D) at (2,-2) {$\cn{DivGroup}$};
\draw[mono](M) -- (G);
\draw[arrow](G) to[out=30,in=150] node[above] {$\cn{G2DG}$} (D);
\draw[arrow](D) to[out=-150,in=-30] node[above] {$\cn{DG2G}$} (G);
\end{tikzpicture}
\vspace{-3.5em}
\end{wrapfigure}

For example, a user might reference an existing theory $\cn{Monoid}$, define a new theory $\cn{Group}$ that extends $\cn{Monoid}$, define a theory $\cn{DivGroup}$ (providing an alternative formulation of groups based on the division operation), and then define two theory morphisms $\cn{G2DG}:\cn{Group}\darr \cn{DivGroup}:\cn{DG2G}$ that witness an isomorphism between these theories.
This would result in the diagram on the right.
Note that we use the syntactic direction for the arrows, e.g., an arrow $m:S\to T$ states that any $S$-expression $E$ (e.g., a sort, term, formula, or proof) can be translated to an $T$-expression $m(E)$.
Crucially, $m(-)$ preserves typing and provability.

The key idea behind implicit morphisms is very simple:
We maintain an additional diagram $I$, which is commutative subdiagram of $D$ and whose morphisms we call \emph{implicit}.
The condition of commutativity guarantees that $I$ has at most one morphism $i$ from theory $S$ to theory $T$, in which case we write $\ipc{i}{S}{T}$.
Commutativity makes the following language extension well-defined: if $\ipc{i}{S}{T}$, then any identifier $c$ that is visible to $S$ may also be used in $T$-expressions; and if $c$ is used in a $T$-expression, the semantics of $c$ is $i(c)$ where $i$ is the uniquely determined implicit morphism $i:S\to T$.

Despite their simplicity, the practical implications of implicit morphism are huge.
For example, in the diagram above, we may choose to label $\cn{G2DG}$ implicit.
Immediately, every abbreviation or theorem that we have formulated in the theory $\cn{Group}$ becomes available for use in $\cn{DivGroup}$ without any syntactic overhead.
We can even label $\cn{DG2G}$ implicit as well if we prove the isomorphism property to ensure that $I$ remains commutative, thus capturing the mathematical intuition that $\cn{Group}$ and $\cn{DivGroup}$ are just different formalizations of the same concept.
While these morphisms must be labeled manually, any inclusion morphism like the one from $\cn{Monoid}$ to $\cn{Group}$ is implicit automatically.

\paragraph{Contribution}
We present a formal system for developing structured theories with implicit morphisms.
Our starting point is the \mmt language \cite{RK:mmt:10}, which already provides a very general setting for defining and working with theories and morphisms.
\mmt is foundation-independent in the sense that it allows embedding a large variety of declarative languages (logics, type-theories, etc.).
Therefore, all our results are foundation-independent --- users of a particular language $L$ can use \mmt directly as a structuring formalism for $L$ or can easily transfer our results to a dedicated implementation of $L$.

More precisely, out contribution is twofold.

Firstly, we give a novel presentation of the syntax and semantics \mmt.
Contrary to the original presentation in \cite{RK:mmt:10}, which hard-coded a single structuring mechanism --- there called \textit{structures} --- our definitions allows for adding arbitrary independent structuring mechanisms.
This required a from-scratch redesign of the original presentation in \cite{RK:mmt:10} (which is why this paper has no preliminaries section).

Based on this extensible definition, we can introduce several additional structuring mechanisms.
Many of these have already been implemented in the \mmt tool but were not formally defined  a formal definition of their semantics as a part of the \mmt language had previously proved too complicated to spell out elegantly.
With our reformulation, this is now not only possible but very easy and elegant.
As an example, we give includes and unions of theories, which induce the most important special cases of implicit morphisms.

Secondly, we describe implicit morphisms as a novel feature of \mmt and give a number of examples.
In particular, we recover the concept of realms \cite{realms} as a special case of implicit morphisms.

In fact, implicit morphisms work so well that we have refactored the \mmt tool in such a way that implicit morphisms are now more primitive than inclusion morphisms.
The semantics of inclusion morphisms is obtained by saying that inclusions are implicit morphisms that map all identifiers to themselves.
Even the fundamental property that a theory may reference its own identifiers is then just a consequence of the fact that all identity morphisms are implicit.
Therefore, surprisingly, adding the new feature of implicit morphisms to the \mmt kernel has made its design much simpler.